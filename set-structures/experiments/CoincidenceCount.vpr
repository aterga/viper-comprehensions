import "../preamble/pair.vpr"
import "../preamble/generic.vpr"

field val: Int

define NODES(g, p)
    !(null in g) && 
    (forall n: Ref :: { n.val } n in g ==> acc(n.val, p))

domain SetExtras[T] {
    function DISJOINT(Set[T], Set[T]): Bool
    axiom { forall A: Set[T], B: Set[T] :: 
            { DISJOINT(A, B) } 
            DISJOINT(A, B) <==> (forall r0: T :: { r0 in A, r0 in B } (r0 in A) ==> !(r0 in B)) }
    axiom { forall S1: Set[T], S2: Set[T] :: 
            { S1 union S2 } 
                (S2 == Set() ==> S1 union S2 == S1) && 
                (S1 == Set() ==> S1 union S2 == S2)
    }
}

function snap(g: Set[Ref], xs: Set[ Ref ], ys: Set[ Ref ]): Map[Pair[Int, Int], Int]
    requires NODES(g, 1/2)
    requires DISJOINT(xs, ys)
    requires g == xs union ys
    ensures domain(result) == DirectProduct(domain(lift(g, xs)), domain(lift(g, ys)))
    ensures forall p: Pair[Int,Int] :: 
        { result[p] }
        // { lift(g, xs)[first(p)].val, lift(g, ys)[second(p)].val }
            p in domain(result) ==> result[p] == let i==(first(p)) in (let j==(second(p)) in 
                                        ((lift(g, xs)[i].val == lift(g, ys)[j].val) ? 1 : 0))


function filt(g: Set[Ref], lo_x:Int, hi_x:Int, lo_y: Int, hi_y: Int, xs: Set[ Ref ], ys: Set[ Ref ]): Set[Pair[Int,Int]]
    requires NODES(g, 1/2)
    ensures result subset DirectProduct(domain(lift(g, xs)), domain(lift(g, ys)))
    ensures forall p: Pair[Int,Int] :: 
        { p in result }
        // { first(p), second(p) }
            p in DirectProduct(domain(lift(g, xs)), domain(lift(g, ys))) ==> 
                (p in result <==> 
                    (let i==(first(p)) in (let j==(second(p)) in (lo_x <= i && i < hi_x && lo_y <= j && j < hi_y))))
    // ensures forall g1 DISJOINT()

define sorted(zs) (forall i: Int, j: Int :: { lift(g, zs)[i].val, lift(g, zs)[j].val }
        i in domain(lift(g, zs)) && j in domain(lift(g, zs)) && i < j ==> 
            lift(g, zs)[i].val < lift(g, zs)[j].val)

define Filter (DirectProduct(domain(lift(g, xs)), domain(lift(g, ys))))
define xs_($index) lift(g, xs)[$index].val
define ys_($index) lift(g, ys)[$index].val


method CoincidenceCount(g: Set[Ref], xs: Set[Ref], ys: Set[Ref]) returns (res: Int)
    requires NODES(g, 1/2)
    requires DISJOINT(xs, ys) && g == xs union ys
    requires sorted(xs) && sorted(ys)

    ensures NODES(g, 1/2)
    ensures res == sum(snap(g, xs, ys), filt(g, 0, size(lift(g, xs)), 0, size(lift(g, ys)), xs, ys))
{
	res := 0
	var m: Int := 0
	var n: Int := 0
    
    var R: Map[Pair[Int,Int], Int]
    var A: Set[Pair[Int,Int]]
    var B: Set[Pair[Int,Int]]
    var C: Set[Pair[Int,Int]]
    var D: Set[Pair[Int,Int]]
    var Z: Set[Pair[Int,Int]]

	while ( m < size(lift(g, xs)) && n < size(lift(g, ys)) )
        invariant NODES(g, 1/2)
        invariant DISJOINT(xs, ys) && g == xs union ys
        invariant sorted(xs) && sorted(ys)

        invariant 0 <= m && m <= size(lift(g, xs))
        invariant 0 <= n && n <= size(lift(g, ys))

		invariant m == size(lift(g, xs)) || (forall j: Int :: 
            { ys_(j) } 
                0 <= j && j < n ==> ys_(j) < xs_(m))
		invariant n == size(lift(g, ys)) || (forall i: Int :: 
            { xs_(i) } 
                0 <= i && i < m ==> xs_(i) < ys_(n))
        
        invariant res == sum(snap(g, xs, ys), filt(g, 0, m, 0, n, xs, ys))

    {
        R := snap(g, xs, ys)

        if ( xs_(m) < ys_(n) )
		{ 
            A := filt(g, 0, m, 0, n, xs, ys)
            B := filt(g, m, m+1, 0, n, xs, ys)
            Z := filt(g, 0, m+1, 0, n, xs, ys)
            assert Z == A union B
            assert sum(R, B) == 0

			m := m+1
		}
        elseif( ys_(n) < xs_(m) )
		{ 
            A := filt(g, 0, m, 0, n, xs, ys)
            B := filt(g, 0, m, n, n+1, xs, ys)
            Z := filt(g, 0, m, 0, n+1, xs, ys)
            assert Z == A union B
            assert sum(R, B) == 0

			n := n+1 
		}
		else 
		{   
            //                    m
            // xs [][][][][][ ][][v][]
            // ys [][][][][][v][]
            //               n
            // res = res0

            //                       m
            // xs [][][][][][] [][v][]
            // ys [][][][][][v][]
            //                 n
            // res = res0+1

            //               n
            //         0 1 2 3 4
            //     0         0
            //     1         0
            //     2         0
            //     3         0
            //   m 4   0 0 0 1
            //     5
            A := filt(g, 0, m,   0, n,   xs, ys)
            B := filt(g, m, m+1, 0, n,   xs, ys)
            C := filt(g, 0, m,   n, n+1, xs, ys)
            D := filt(g, m, m+1, n, n+1, xs, ys)
            Z := filt(g, 0, m+1, 0, n+1, xs, ys)
            assert Z == A union B union C union D

            assert sum(R, A) == res
            assert sum(R, B) == 0
            assert sum(R, C) == 0
            assert sum(R, D setminus Set(pair(m, n))) == 0
            // assert A union B union C == A union B
            assert sum(R, A union B union C) == sum(R, A union B)
            
            res := res+1
            m := m+1
			n := n+1 
		}
    }


    R := snap(g, xs, ys)

    A := filt(g, 0, m, 0, n, xs, ys)
    B := filt(g, m, size(lift(g, xs)), 0, n, xs, ys)
    C := filt(g, 0, m, n, size(lift(g, ys)), xs, ys)
    D := filt(g, m, size(lift(g, xs)), n, size(lift(g, ys)), xs, ys)
    Z := filt(g, 0, size(lift(g, xs)), 0, size(lift(g, ys)), xs, ys)
    assert sum(R, B) == 0
    assert sum(R, C) == 0
    assert sum(R, D) == 0
    assert Z == A union B union C union D

    // assert false
}
