

import "generic.vpr"


define ACCESS_NODES(g, p)
    (forall n: Ref :: { n.val } n in g ==> acc(n.val, p))


function snap(g: Set [Ref]): Map[Ref, Int]
    requires ACCESS_NODES(g, wildcard)
    // ensures forall n: Ref ::
    //     { n.val }
    //     n in g ==> NewTuple(n, n.val) in result
    ensures forall u:Ref, v:Int :: 
        // { Map_in(result, u, v) }
        { v in Map_values(result), Map_lookup(result, u) }
        { v in Map_values(result), u in Map_keys(result) }
        { v in Map_values(result), u.val }
            (v == Map_lookup(result, u) && v in Map_values(result) && u in Map_keys(result))
            ==>
            (u in g && u.val == v)
    ensures forall u:Ref ::
        { u.val }
        { Map_lookup(result, u) }
            u in g ==> Map_lookup(result, u) == u.val
    // ensures forall a: Ref ::
    //     { a.val }
    //         dum1(g setminus Set(a))


    // ensures forall u: Ref, F: Set[Ref] ::
    //     { u.val, snap(F) }
    //         F subset g && u in F ==> Map_lookup(snap(F), u) == u.val
            
    ensures forall u: Ref, g1: Set[Ref] :: 
        { u.val, g1 setminus Set(u) }
            dum((g1 setminus Set(u)) subset g)

    // ensures forall u:Ref ::
    //     { Map_lookup(result, u) }
    //         Map_lookup(result, u) == u.val ==> u in g
    ensures Map_keys(result) == g
    // ensures forall F: Set[Ref] :: 
    //     {  } 

// method hello()
// {
//     var a: Set[Ref]
//     inhale ACCESS_NODES(a, write)
//     var b: Set[Int]
//     // assume b == snap(a)

//     assert false
// }

define min_all(g) (min(snap(g), g))

// Comp a: Ref { exp(a) | filter(a) }
// define comp()

method flipOne_1(g: Set [Ref], z: Ref, x: Ref, y: Ref, m: Int) 
	requires forall n: Ref:: n in g ==> acc(n.val) 
	requires x in g && y in g && z in g && x != y && x != z && y != z
	requires m == min_all(g) && 0 <= m 
{
	x.val := -1 * m 
    y.val := -1 * m 
    z.val := -1 * m 

    // x.val := -1 * m 
    
    

    // assert min(snap(g), g) == __min__(min(snap(g), g setminus Set(x)), Map_lookup(snap(g), x))
    // assert min(snap(g), g) <= min(snap(g), g setminus Set(x))
    

    // assert Map_card(snap(g)) == |g|
    // assert Map_in(snap(g), x, -1 * m)
    // assert Map_lookup(snap(g), x) == x.val

    // assert forall RA: Map[Ref, Int], RB: Map[Ref, Int], F: Set[Ref] :: 
    //         { min(RA, F), min(RB, F) }
    //             // F subset Map_keys(RA) && F subset Map_keys(RB) && 
    //             (forall a: Ref :: 
    //                 { Map_lookup(RA, a) }
    //                 { Map_lookup(RB, a) }
    //                     a in F ==> 
    //                     Map_lookup(RA, a) == Map_lookup(RB, a))
    //             ==> min(RA, F) == min(RB, F)

    // assert (forall a: Ref :: 
    //             a in g setminus Set(x) ==> 
    //             //Map_lookup(snap(g), a) == a.val)
    //             Map_in(snap(g), a, a.val))
    // assert (forall a: Ref :: 
    //             a in g setminus Set(x) ==> 
    //             Map_lookup(snap(g), a) == Map_lookup(old(snap(g)), a))
    // assert min(snap(g), ((g setminus Set(x)) setminus Set(y)) setminus Set(z)) == 
    //        min(old(snap(g)), ((g setminus Set(x)) setminus Set(y)) setminus Set(z))
    
    // assert Map_lookup(snap(g), x) == -m
    // assert min(snap(g), Set(x)) == -m
    // assert min(snap(g), Set(x,y)) == -m
    // assert min(snap(g), Set(x,y,z)) == -m
    // var a: Ref 
    // assume  dum0(min(old(snap(g)), g setminus Set(x)))
    // assume dum2(old(snap(g)))
    // assume dum1(g setminus Set(x))
    // assume dum2(old(snap(g)))
    // assume  dum0(min(old(snap(g)), g))

    // assert min(snap(g), g) == -m
	assert min_all(g) == -m 
    // assert false
}

domain Tuple[T, S] {
    function left(t: Tuple[T,S]): T
    function right(t: Tuple[T,S]): S
}
field val: Int
function snap2(g: Set [Ref]): Tuple[Set[Int], Int]
    requires forall n: Ref :: n in g ==> acc(n.val)
    ensures forall n: Ref :: n in g ==> n.val in left(result)
    // ensures forall v: Int :: v in left(result) ==> get(v, right(result)) in g

domain Dummy {
    function dum0(d: Int): Bool
    function dum(d: Bool): Bool
    // function dum1(s: Set[Ref]): Bool
    // function dum2(d: Map[Ref, Int]): Bool

    // axiom axT {
    //     forall s: Set[Ref] :: 
    //         dum1(s) == true
    // }
}
